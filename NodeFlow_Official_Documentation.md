# NodeFlow Project Documentation

---
*Version 1.5 (Generated by Jules)*
*Date: 2025-09-18*
---

## **Table of Contents**
- [1. Preface & Introduction](#1-preface--introduction)
  - [1.1. The Need for a Modern Automation Tool](#11-the-need-for-a-modern-automation-tool)
  - [1.2. Introduction to OPC UA](#12-introduction-to-opc-ua)
- [2. Project Overview & System Architecture](#2-project-overview--system-architecture)
  - [2.1. Project File Structure](#21-project-file-structure)
  - [2.2. Architectural Design Principles](#22-architectural-design-principles)
  - [2.3. Asynchronous and Synchronous Integration](#23-asynchronous-and-synchronous-integration)
  - [2.4. Technology Stack](#24-technology-stack)
- [3. OPC UA Communication](#3-opc-ua-communication)
  - [3.1. OPC UA Communication Engine (opcua_logic.py)](#31-opc-ua-communication-engine-opcua_logicpy)
  - [3.2. High-Efficiency Subscription Model](#32-high-efficiency-subscription-model)
  - [3.3. Robust Error Handling and Automatic Reconnection](#33-robust-error-handling-and-automatic-reconnection)
- [4. Graphical Sequencer](#4-graphical-sequencer)
  - [4.1. SequenceEngine Class: The Execution Backend](#41-sequenceengine-class-the-execution-backend)
  - [4.2. Graphical Components: The Visual Building Blocks](#42-graphical-components-the-visual-building-blocks)
  - [4.3. Advanced Flow Control: Loops, Conditions, and Parallel Execution](#43-advanced-flow-control-loops-conditions-and-parallel-execution)
  - [4.4. Interactive Debugging and Execution Control](#44-interactive-debugging-and-execution-control)
  - [4.5. Undo/Redo Framework: The Command Design Pattern](#45-undoredo-framework-the-command-design-pattern)
- [5. User Interface (UI) Component Reference](#5-user-interface-ui-component-reference)
  - [5.1. Main Window & Orchestrator (main_window.py)](#51-main-window--orchestrator-main_windowpy)
  - [5.2. Dashboard and Widgets (widgets/)](#52-dashboard-and-widgets-widgets)
  - [5.3. Other UI Components](#53-other-ui-components)
- [6. Application Entry and User Guide](#6-application-entry-and-user-guide)
  - [6.1. Application Entry Point (main.py)](#61-application-entry-point-mainpy)
  - [6.2. Persistent Settings Management (settings_dialog.py and QSettings)](#62-persistent-settings-management-settings_dialogpy-and-qsettings)
- [7. User Guide](#7-user-guide)
  - [7.1. Establishing a Connection and Browsing](#71-establishing-a-connection-and-browsing)
  - [7.2. Building and Interacting with a Dashboard](#72-building-and-interacting-with-a-dashboard)
  - [7.3. Creating and Executing a Basic Automation Sequence](#73-creating-and-executing-a-basic-automation-sequence)
  - [7.4. Using Loops and Debugging a Sequence](#74-using-loops-and-debugging-a-sequence)
  - [7.5. Finding Nodes Across the Project](#75-finding-nodes-across-the-project)
- [8. Conclusion & Glossary](#8-conclusion--glossary)
  - [8.1. Conclusion](#81-conclusion)
  - [8.2. Glossary of Terms](#82-glossary-of-terms)

---

# **1. Preface & Introduction**

## **1.1. The Need for a Modern Automation Tool**

In the era of Industry 4.0 and the Industrial Internet of Things (IIoT), the manufacturing and automation landscapes are undergoing a profound transformation. The rigid, siloed systems of the past are giving way to interconnected, data-driven ecosystems. This evolution demands a new generation of tools—tools that are not only powerful but also flexible, accessible, and capable of bridging the historical divide between the factory floor (Operational Technology, or OT) and enterprise systems (Information Technology, or IT).

For decades, automation has been the domain of highly specialized engineers wielding proprietary software and complex programming languages specific to certain Programmable Logic Controllers (PLCs) or Distributed Control Systems (DCS). While effective, this approach has several inherent limitations in the modern context:

*   **High Barrier to Entry:** Developing or modifying automation logic often requires deep expertise in specific vendor ecosystems (e.g., Siemens TIA Portal, Rockwell Studio 5000). This creates a skills gap and makes it difficult for process experts, researchers, or IT professionals to contribute directly to automation workflows.
*   **Rigidity and Lack of Flexibility:** Traditional systems are often designed for a single, specific purpose and can be difficult and costly to adapt. As production needs change or new data acquisition requirements emerge, modifying these systems can be a slow and cumbersome process.
*   **Data Silos:** Data generated on the factory floor is frequently locked within proprietary protocols or isolated networks. Extracting this data for analysis, visualization, or integration with higher-level business systems can be a significant challenge, hindering efforts to gain real-time insights into operations.
*   **Poor Integration Capabilities:** Connecting disparate systems—a PLC from one vendor, a sensor from another, and a database in the cloud—can be a complex integration project in itself, often requiring multiple protocol converters, custom drivers, and middleware.

It is precisely these challenges that **NodeFlow** was conceived to address. NodeFlow represents a paradigm shift in automation and data acquisition. It is built on the philosophy that creating sophisticated, data-rich automation sequences should be an intuitive and visual process, accessible to a broader range of users without sacrificing power or flexibility.

By leveraging a graphical, node-based editor, NodeFlow empowers users to:

*   **Visualize Logic:** Instead of writing hundreds of lines of code, users can build workflows by dragging, dropping, and connecting nodes. This visual approach makes the logic easier to understand, debug, and maintain.
*   **Democratize Automation:** It lowers the barrier to entry, allowing engineers, technicians, and even scientists to build and deploy their own custom automation and test sequences without needing to be PLC programming experts.
*   **Promote Rapid Prototyping:** New ideas for process control or data analysis can be quickly prototyped and tested in a live environment, dramatically accelerating development cycles.
*   **Ensure Seamless Integration:** At its core, NodeFlow is built upon the open standard of OPC UA, enabling it to communicate natively with a vast and growing ecosystem of industrial devices and software.

NodeFlow is more than just a tool; it is a platform designed for the future of industry—a future where data flows freely, where systems are interoperable by design, and where the power to automate and innovate is in the hands of those who understand the process best.

[NOTE: Insert a diagram here showing the traditional, siloed approach vs. the modern, integrated approach enabled by tools like NodeFlow.]

## **1.2. Introduction to OPC UA**

To fully appreciate the capabilities of NodeFlow, one must first understand its primary communication backbone: **OPC UA (Open Platform Communications Unified Architecture)**. OPC UA is not merely a protocol; it is a comprehensive, service-oriented framework for secure and reliable information exchange in industrial automation. It is the designated successor to the classic OPC standard (often called OPC Classic), which, while successful, was based on Microsoft's DCOM technology and thus limited to Windows platforms.

OPC UA was designed from the ground up to overcome these limitations and meet the demands of modern industrial environments. It is the cornerstone of interoperability for Industry 4.0.

### **What is "Unified Architecture"?**

The "Unified Architecture" in OPC UA refers to its integration of the functionalities of previous OPC Classic specifications (like OPC Data Access, Alarms & Events, and Historical Data Access) into a single, extensible framework. This means that a single OPC UA connection can handle real-time data, historical data, alarms, and complex command execution, drastically simplifying the architecture of industrial applications.

### **Key Features and Benefits of OPC UA**

NodeFlow leverages the full power of OPC UA. Understanding these core features is key to unlocking NodeFlow's potential:

*   **Platform Independence:** This is arguably the most significant advantage over OPC Classic. OPC UA is not tied to any specific operating system or programming language. An OPC UA server can run on a Linux-based embedded controller, a Windows-based SCADA system, or a cloud platform, and an OPC UA client like NodeFlow can communicate with all of them seamlessly. This is the feature that allows NodeFlow, a Python-based application, to interact with the entire industrial world.

*   **Robust Security Model:** Security is not an afterthought in OPC UA; it is a fundamental part of the specification. It provides a multi-layered security model that includes:
    *   **Authentication:** Verifying the identity of client applications and users. This can be done through username/password, or more securely through X.509 certificates.
    *   **Authorization:** Controlling what an authenticated user or application is allowed to do (e.g., read a variable, write to another, execute a method).
    *   **Encryption and Integrity:** Ensuring that data transmitted over the network cannot be read (confidentiality) or tampered with (integrity). All communications can be encrypted and digitally signed.
    NodeFlow supports these security mechanisms, allowing it to connect securely to production-critical systems.

*   **Rich Information Modeling:** This is where OPC UA truly shines and what makes it an "information" model, not just a "data" model. Unlike simple protocols that just transmit raw data values, OPC UA allows servers to expose a structured **Address Space**. This address space is a full mesh network of **Nodes**, where nodes can represent not just simple variables (like temperature or pressure), but also:
    *   **Objects:** Grouping related variables and methods into logical units (e.g., a "Motor" object with variables for Speed and Temperature, and methods for "Start" and "Stop").
    *   **Methods:** Functions that can be called by a client to execute an action on the server.
    *   **Relationships:** Defining how different nodes are related to each other.
    NodeFlow's Server Browser is a direct visual representation of this address space, and the Sequencer's Method Call node is a tool for directly interacting with these powerful, object-oriented models.

*   **Scalability:** The OPC UA framework is designed to be scalable from the smallest embedded sensor to the largest enterprise-level cloud application. The information models can be as simple or as complex as needed, allowing it to represent a single device or an entire factory.

*   **High-Performance Subscriptions:** Instead of forcing a client to continuously poll for data changes (which is inefficient and network-intensive), OPC UA provides a powerful subscription mechanism. A client like NodeFlow can tell the server, "Notify me only when this value changes." The server then monitors the value and sends a notification to the client when a change occurs. This is a highly efficient, push-based model that ensures real-time data updates with minimal network overhead. The `DisplayWidget` in NodeFlow is a prime example of this mechanism in action.

In essence, by choosing OPC UA as its foundational technology, NodeFlow ensures that it is not just another proprietary tool but an open, secure, and future-proof platform for industrial automation and data integration. It stands on the shoulders of a global standard to provide its users with unparalleled connectivity and power.

[NOTE: Add a simple diagram illustrating the Client-Server architecture of OPC UA, with NodeFlow as the client connecting to various servers like PLCs, SCADA systems, etc.]

---

# **2. Project Overview & System Architecture**

This chapter provides a high-level overview of the NodeFlow project, its structure, and the core architectural principles that guide its design. Understanding this architecture is essential for developers looking to extend or maintain the application.

## **2.1. Project File Structure**

A well-organized file structure is crucial for maintainability. NodeFlow's structure is designed to separate concerns, making it easy to locate different parts of the application's logic.

```
/
├── app/
│   ├── core/
│   │   └── opcua_logic.py        # Core OPC UA client logic, handles all communication.
│   ├── resources/
│   │   ├── icons/                # Application icons.
│   │   └── styles/               # QSS stylesheets for themes (light/dark).
│   ├── ui/
│   │   ├── widgets/              # Dashboard widgets (Display, Button, Plotter, etc.).
│   │   ├── add_widget_dialog.py  # Dialog for adding new dashboard widgets.
│   │   ├── main_window.py        # The main application window and UI orchestrator.
│   │   ├── sequence_editor.py    # The graphical node-based sequence editor.
│   │   ├── server_tree.py        # The OPC UA server browser tree view.
│   │   └── ...                   # Other UI components and dialogs.
│   └── utils/
│       ├── logger.py             # Logging configuration and custom Qt log widget.
│       └── paths.py              # Utility for handling resource paths (for PyInstaller).
├── layouts/
│   └── *.json                    # Saved project files containing dashboard and sequence layouts.
├── main.py                       # The main entry point of the application.
├── main.spec                     # PyInstaller specification file for building the executable.
└── requirements.txt              # List of Python dependencies.
```

### **Key Directories Explained:**

*   **`app/`**: This is the main package for the application source code.
    *   **`app/core/`**: Contains the non-visual, backend business logic. The key component here is `opcua_logic.py`, which is completely decoupled from the user interface.
    *   **`app/resources/`**: Holds all static assets required by the application, such as icons for buttons and windows, and `.qss` files which define the visual style of the UI themes.
    *   **`app/ui/`**: This is the largest part of the application, containing all the PyQt6 user interface code.
        *   `main_window.py` acts as the central hub.
        *   The `widgets/` subdirectory contains the individual, modular components that can be placed on the dashboard.
        *   Other files define specific parts of the UI, like the sequence editor, dialog boxes, and tree views.
    *   **`app/utils/`**: Contains helper modules and utility functions that are used across the application, such as the logging setup.
*   **`layouts/`**: This directory contains example `.json` project files that can be loaded into NodeFlow. These files are a great way to see examples of complex dashboards and sequences.
*   **Root Directory**: The root contains the application's entry point (`main.py`), build scripts (`main.spec`), and dependency information (`requirements.txt`).

## **2.2. Architectural Design Principles**

NodeFlow is built upon several key architectural principles designed to ensure it is robust, maintainable, and extensible.

### **Separation of Concerns (Model-View-Controller Variant)**

The application follows a design pattern that closely resembles Model-View-Controller (MVC), which separates the application's logic into three interconnected parts:

*   **Model (The Data and Business Logic):** This is the backend of the application. It manages the data and the rules for interacting with it. In NodeFlow, this is primarily represented by:
    *   **`OpcuaClientLogic` class:** It knows nothing about the UI. Its sole responsibility is to manage the connection to the OPC UA server, handle subscriptions, and execute commands.
    *   **`SequenceEngine` class:** It executes the logic of a sequence but does not draw it. It simply processes the node graph and emits signals about its state.
    *   **The Project JSON file:** This file acts as the persistent model, storing the state of the dashboard and sequences.

*   **View (The User Interface):** This is the visual representation of the model. It's what the user sees and interacts with.
    *   **`MainWindow` and its components:** The main window, docks, toolbars.
    *   **`BaseWidget` and its subclasses:** The visual representation of data on the dashboard.
    *   **`SequenceEditor` and `SequenceNode`:** The graphical representation of a sequence.

*   **Controller (The Orchestrator):** The controller acts as the intermediary, translating user actions from the View into commands for the Model, and updating the View when the Model changes.
    *   **`MainWindow`:** This class is the primary controller. For example, when a user clicks the "Connect" button (View), a slot in `MainWindow` (Controller) calls the `connect` method on the `OpcuaClientLogic` instance (Model).
    *   **`SequenceScene`:** It handles user input in the sequence editor, such as creating and connecting nodes, and modifies the underlying sequence data (Model).

[NOTE: Insert a diagram showing the MVC-like architecture. A box for "Model" (OpcuaClientLogic, SequenceEngine), a box for "View" (UI Components), and a box for "Controller" (MainWindow). Arrows should show the flow of control and data.]

### **Event-Driven and Signal/Slot-Based Communication**

Instead of different parts of the code calling each other directly in a long, complicated chain, NodeFlow uses an event-driven approach. This is primarily achieved through **PyQt's signal and slot mechanism**.

*   A **signal** is emitted when a particular event occurs (e.g., a button is clicked, data is received).
*   A **slot** is a function that is called in response to a signal.

This creates a loosely coupled system. For example, the `OpcuaClientLogic` does not know or care what happens when a connection is lost. It simply emits a `connection_lost_callback`. The `MainWindow` connects this signal to a slot (`on_connection_lost`) that knows how to update the UI. This makes the code much easier to manage and extend.

## **2.3. Asynchronous and Synchronous Integration**

One of the most critical architectural features of NodeFlow is its hybrid use of asynchronous and synchronous code.

*   **Synchronous World (PyQt):** User interface operations are inherently synchronous and must run in the main UI thread. A long-running operation in this thread will freeze the entire application, leading to a terrible user experience.
*   **Asynchronous World (OPC UA):** Network communication is inherently unpredictable and can be slow. Waiting for a server to respond would freeze a synchronous application. `asyncio` is Python's standard library for writing concurrent code using an async/await syntax.

The challenge is to make these two worlds coexist. This is solved in NodeFlow using the **`qasync`** library.

`qasync` provides a `QEventLoop` that integrates the `asyncio` event loop with Qt's event loop. This allows the application to run `asyncio` tasks in the background while the Qt UI remains fully responsive.

### **The `AsyncRunner` Bridge**

To make this integration clean and easy to use, NodeFlow implements a small helper class, `AsyncRunner`. This class acts as a bridge, allowing the synchronous Qt world to safely launch and forget asynchronous tasks.

Here's how it works in practice:

1.  A user clicks a "Connect" button in the `MainWindow`.
2.  The button's `clicked` signal is connected to a synchronous slot (a regular Python method) in `MainWindow`.
3.  This slot cannot directly `await` the `opcua_logic.connect()` method, as that would freeze the UI.
4.  Instead, it submits the asynchronous task to the `AsyncRunner`.

**Pseudo-code Example:**

```python
# In MainWindow (Synchronous Qt code)
class MainWindow(QMainWindow):
    def __init__(self):
        # ...
        self.async_runner = AsyncRunner()
        self.connect_button.clicked.connect(self.on_connect_clicked)

    def on_connect_clicked(self):
        # We can't do 'await self.opcua_logic.connect()' here.
        # So, we submit the coroutine to the runner.
        # The runner will schedule it on the asyncio event loop.
        coro = self.opcua_logic.connect("opc.tcp://...")
        self.async_runner.submit(coro)
        print("Connect command sent. UI is not frozen.")

# In OpcuaClientLogic (Asynchronous code)
class OpcuaClientLogic:
    async def connect(self, url):
        # This code can use 'await' freely.
        print("Attempting to connect...")
        await self.client.connect() # This might take several seconds.
        print("Connection successful!")
```

This architecture is fundamental to NodeFlow's performance and responsiveness. It ensures that slow network operations never impact the user's ability to interact with the application.

## **2.4. Technology Stack**

NodeFlow is built on a foundation of powerful, open-source Python libraries.

*   **`PyQt6`**: The primary framework for the entire graphical user interface. It provides the widgets, layout managers, and the application's main event loop.
*   **`asyncua`**: A high-performance, asynchronous OPC UA client and server library for Python. This is the engine that powers all OPC UA communication in NodeFlow.
*   **`qasync`**: The critical bridge library that allows `asyncio` to work seamlessly with PyQt's event loop, enabling a responsive UI with non-blocking network operations.
*   **`numpy` & `pandas`**: Included for powerful numerical and data analysis capabilities within the sequencer's `Compute` node, allowing for complex data processing tasks.
*   **`matplotlib`**: Used by the `PlotterWidget` to create real-time data visualizations on the dashboard.
*   **`OpenCV`, `easyocr`, `PyTorch`**: These libraries provide advanced computer vision and AI capabilities that can be integrated into automation flows for tasks like visual inspection, optical character recognition, and machine learning inference.
*   **`PyInstaller`**: The tool used to package the Python application and all its dependencies into a single, standalone executable for easy distribution.

---

# **3. OPC UA Communication**

The heart of NodeFlow's connectivity lies in its robust and efficient OPC UA communication engine. This chapter delves into the core components that handle all interactions with OPC UA servers, from establishing connections and managing subscriptions to handling errors and ensuring resilience.

## **3.1. OPC UA Communication Engine (`opcua_logic.py`)**

The `app/core/opcua_logic.py` file contains the `OpcuaClientLogic` class, which serves as the single point of contact for all OPC UA operations. It is designed to be completely independent of the user interface, ensuring a clean separation of concerns. All of its network-dependent methods are asynchronous (`async def`), allowing them to be run in the background without blocking the main UI thread.

### **The `OpcuaClientLogic` Class**

This class encapsulates an `asyncua.Client` instance and provides a set of high-level methods for interacting with it.

#### **Key Methods and Properties:**

*   `self.client`: The raw `asyncua.Client` object.
*   `self.is_connected`: A boolean flag indicating the current connection status.
*   `self.subscription`: The `asyncua.Subscription` object used for real-time data updates.
*   `self.connection_lost_callback`: A callback function (provided by `MainWindow`) that is called when the connection is lost.

---

**`async def connect(self, url, username=None, password=None)`**

This method establishes a connection to the OPC UA server and creates the data subscription.

*   **Purpose:** To connect to a specified server endpoint. If a connection already exists, it will be gracefully disconnected first to ensure a clean state.
*   **Arguments:**
    *   `url` (str): The endpoint URL of the OPC UA server (e.g., `"opc.tcp://localhost:4840/freeopcua/server/"`).
    *   `username` (str, optional): The username for session authentication.
    *   `password` (str, optional): The password for session authentication.
*   **Usage:**
    ```python
    opcua_handler = OpcuaClientLogic()
    try:
        await opcua_handler.connect("opc.tcp://my-server:4840")
        print("Connection Successful!")
    except Exception as e:
        print(f"Connection Failed: {e}")
    ```

---

**`async def disconnect(self)`**

Gracefully disconnects from the server, deleting the subscription and closing the client session.

*   **Purpose:** To cleanly terminate the connection and release all associated resources.
*   **Usage:**
    ```python
    await opcua_handler.disconnect()
    ```

---

**`async def read_value(self, node)`**

Reads the current value of a single node from the server.

*   **Purpose:** To perform a one-time read of a node's value.
*   **Arguments:**
    *   `node` (`asyncua.Node`): The node object to read. This object is typically obtained first via `find_node()`.
*   **Returns:** The value of the node. The type of the value depends on the node's data type on the server.
*   **Usage:**
    ```python
    my_node = await opcua_handler.find_node("ns=2;i=123")
    value = await opcua_handler.read_value(my_node)
    print(f"The current value is: {value}")
    ```

---

**`async def write_value(self, node, value, datatype)`**

Writes a value to a single node on the server.

*   **Purpose:** To change the value of a writable node.
*   **Arguments:**
    *   `node` (`asyncua.Node`): The node object to write to.
    *   `value`: The new value to write.
    *   `datatype` (`ua.VariantType`): The OPC UA data type of the value being written.
*   **Usage:**
    ```python
    my_node = await opcua_handler.find_node("ns=2;i=124")
    # The datatype can often be read from the node itself
    datatype = await my_node.read_data_type_as_variant_type()
    await opcua_handler.write_value(my_node, 123.45, datatype)
    ```

---

**`async def call_method(self, parent_node_id, method_node_id, *args)`**

Calls a method on an OPC UA object.

*   **Purpose:** To execute a function on the server.
*   **Arguments:**
    *   `parent_node_id` (str): The Node ID of the object that owns the method.
    *   `method_node_id` (str): The Node ID of the method to be called.
    *   `*args`: Any input arguments required by the method.
*   **Returns:** A list of output arguments from the method call.
*   **Usage:**
    ```python
    # Assuming "MyObject" has a method "MyMethod" that takes one integer argument
    parent_node = "ns=2;s=MyObject"
    method_node = "ns=2;s=MyMethod"
    result = await opcua_handler.call_method(parent_node, method_node, 42)
    print(f"Method returned: {result}")
    ```

## **3.2. High-Efficiency Subscription Model**

One of the most powerful features of OPC UA, and a core principle of NodeFlow's design, is the use of subscriptions for real-time data updates. This model is vastly more efficient than traditional polling.

*   **Polling:** The client repeatedly asks the server, "What is the value now? What is the value now?". This creates constant network traffic, even if the value hasn't changed.
*   **Subscription:** The client tells the server, "Please notify me whenever this value changes." The server then does the work of monitoring the value and only sends a message when a change actually occurs.

NodeFlow implements this model using two key classes: `OpcuaClientLogic` and `SubscriptionHandler`.

[NOTE: Insert a diagram comparing Polling (many arrows from client to server) vs. Subscription (one arrow from client to server to set up, then arrows from server to client on change).]

### **The `SubscriptionHandler` Class**

This class is a dedicated callback processor. An instance of this class is passed to the `asyncua` library when the subscription is created. The library will then call methods on this instance when events occur.

*   **`datachange_notification(self, node, val, data)`:** This is the most important method. It is called by `asyncua` every time a subscribed node's value changes. Its job is to take the new value (`val`) and the `node` it belongs to and forward it to the main logic class.
*   **`status_change_notification(self, status)`:** This method is called when the status of the subscription itself changes. This is a crucial part of the error handling mechanism, as a bad status (e.g., `Timeout`) is often the first sign that the connection to the server has been lost.

### **The Subscription Workflow**

1.  **Subscription Creation:** When `OpcuaClientLogic.connect()` is called, it creates a subscription on the server with a requested publishing interval (e.g., 500ms). It passes an instance of `SubscriptionHandler` to process the callbacks.
2.  **Subscribing a Widget:** A widget, like `DisplayWidget`, needs to show a live value. During its `setup_widget` method, it calls `opcua_logic.subscribe_to_node_change(self.node, self.on_data_changed)`.
3.  **Mapping:** Inside `subscribe_to_node_change`, the `OpcuaClientLogic` does two things:
    a. It tells the `asyncua` subscription to monitor the requested node.
    b. It stores the widget's callback method (`self.on_data_changed`) in a dictionary, `self.node_callback_map`, using the node as the key.
4.  **Data Change Event:** The value changes on the OPC UA server. The server sends a notification to NodeFlow.
5.  **Notification Handling:** The `asyncua` library receives the notification and calls `SubscriptionHandler.datachange_notification()` with the node and the new value.
6.  **Dispatching:** The `SubscriptionHandler` immediately calls `OpcuaClientLogic.dispatch_data_change()`.
7.  **Callback Execution:** `dispatch_data_change` looks up the node in its `node_callback_map`, finds the `DisplayWidget`'s `on_data_changed` method, and calls it with the new value. The widget then updates its display label.

This loosely coupled, callback-driven architecture is what allows many different widgets to subscribe to many different nodes efficiently and without interfering with each other.

## **3.3. Robust Error Handling and Automatic Reconnection**

In any real-world network application, errors and disconnections are inevitable. NodeFlow is designed to be resilient to these issues through a combination of centralized error handling and an automatic reconnection mechanism.

### **Centralized Error Handling**

To avoid writing `try...except` blocks in every single network-related method, `OpcuaClientLogic` uses a private wrapper method: `_call_with_error_handling`.

Almost every `async` call to the `asyncua` library is wrapped in this method. It provides a single place to catch common communication exceptions, such as `UaError` (general OPC UA errors), `asyncio.TimeoutError`, and `ConnectionError`.

If one of these errors is caught, it's a strong indication that the connection is no longer healthy. The wrapper then logs the error and, most importantly, calls the `self.connection_lost_callback()` if it has been set.

### **Connection Loss Detection**

NodeFlow has two primary ways of detecting a lost connection:

1.  **Active Failure:** An operation (like a read or write) fails and throws an exception. This is caught by the `_call_with_error_handling` wrapper as described above.
2.  **Passive Failure:** The application is idle, but the network connection is severed (e.g., a network cable is unplugged). This is detected by the `SubscriptionHandler.status_change_notification()`. The OPC UA server and client exchange keep-alive messages, and if these fail, the server sends a bad status notification. This triggers the `connection_lost_callback`.

### **Automatic Reconnection Logic**

The `connection_lost_callback` is set by `MainWindow` to point to its own `on_connection_lost` method. When this method is called:

1.  It logs that the connection has been lost.
2.  It immediately updates the UI to reflect the disconnected state (e.g., the status indicator in the title bar turns red).
3.  It sets a flag, `self.is_reconnecting = True`, to prevent multiple reconnect attempts from being triggered.
4.  It starts a `QTimer` (`self.reconnect_timer`) that will fire every few seconds (e.g., 5 seconds).

The `reconnect_timer`'s `timeout` signal is connected to the `attempt_reconnect` slot. This slot simply calls the `async_runner` to submit a new `connect()` task.

*   If the connection attempt succeeds, the `on_connection_success` slot is called, which stops the `reconnect_timer` and restores the UI to its connected state.
*   If the connection attempt fails, the `on_connection_failed` slot is called, which logs the failure. The `reconnect_timer` continues to be active, so it will try again after another 5 seconds.

This robust system ensures that NodeFlow can gracefully handle unexpected network issues and will automatically restore its connection as soon as the server becomes available again, providing a seamless experience for the end-user.

---

# **4. Graphical Sequencer**

The graphical sequencer is the most powerful and complex feature of NodeFlow. It provides a node-based, visual programming environment where users can create sophisticated automation and data processing workflows without writing traditional code. This chapter breaks down the architecture of the sequencer, from its visual components to its execution backend.

## **4.1. `SequenceEngine` Class: The Execution Backend**

The `SequenceEngine` is the non-visual "brain" of the sequencer. It resides in `app/ui/sequencer_editor.py` but is designed to be completely decoupled from the graphical elements. Its sole responsibility is to take the serialized dictionary representing a sequence and execute it.

This separation is a key architectural choice. The visual editor (`SequenceEditor`) can be changed or even replaced without affecting the execution logic. The engine communicates its state back to the UI via Qt signals, which `MainWindow` then routes to the appropriate `SequenceEditor` instance for visual updates.

### **Core Concepts of the Engine**

*   **Asynchronous Execution:** The entire engine is built on `asyncio`. The main execution method, `_run_main_loop`, is an `async` function that is started as a background task by the `AsyncRunner`. This ensures that even long-running sequences with delays do not freeze the UI.
*   **State-Driven Logic:** The engine is a state machine that moves from one node to the next based on the successful execution of the current node and the conditions on the outgoing connections.
*   **Data Context:** The engine maintains a dictionary called `self.execution_context`. When a node that produces an output (like a `Method Call` or `Static Value` node) executes successfully, it stores its return value in this dictionary, keyed by its unique UUID. Subsequent nodes that are configured to use a data input can then retrieve this value from the context.

### **The Execution Flow**

1.  **Initiation:** The `run` method is the entry point. It finds the "start node" of the sequence (a node with no incoming execution connections) and launches the main execution task, `_run_main_loop`.
2.  **The Main Loop (`_execute_graph`):** This is the core of the engine. It's a `while` loop that continues as long as there is a `current_node` to process.
3.  **Node Execution:** Inside the loop, it calls `self.execute_node(current_node)`. This method acts as a dispatcher, calling a specific handler method based on the node's `node_type` (e.g., `execute_method_call_node`, `execute_delay_node`).
4.  **State Signaling:** Before and after execution, the engine emits signals (`node_state_changed`, `connection_state_changed`) with the UUID of the item and its new state (`running`, `success`, `failed`). The UI listens for these signals to provide real-time highlighting.
5.  **Finding the Next Node:** After a node executes successfully, the engine calls `find_next_node_and_connection`. It iterates through the outgoing execution connections of the completed node and evaluates their conditions using the result of the completed node. The first connection whose condition evaluates to `True` is chosen, and its destination node becomes the `current_node` for the next iteration of the loop.
6.  **Termination:** The loop ends when no next node can be found (the end of a sequence branch) or when the `_stop_requested` flag is set. The engine then emits the `execution_finished` signal.

## **4.2. Graphical Components: The Visual Building Blocks**

The entire visual editor is built using Qt's `QGraphicsView` framework, which is designed for creating interactive scenes with many graphical items.

*   **`SequenceEditor` (`QGraphicsView`):** This is the main widget that hosts the scene. It provides the viewport for the user, and handles user-level interactions like zooming (Ctrl+Wheel) and panning (Middle Mouse Drag). It also contains the minimap and the find widget.

*   **`SequenceScene` (`QGraphicsScene`):** This is the "canvas" that contains all the nodes and connections. It is responsible for:
    *   Drawing the grid background.
    *   Handling mouse events to create, select, and move items.
    *   Managing the context menu that appears when right-clicking on the canvas or on an item.
    *   Housing the `QUndoStack` for the undo/redo framework.

*   **`SequenceNode` (`QGraphicsObject`):** The visual representation of a single node in the sequence. It's a complex object that draws the node's body, title, and state highlights. It also acts as a parent container for its ports.

*   **`Port` and `DataSocket` (`QGraphicsObject`):** These are the small circular (execution) and square (data) connection points on a `SequenceNode`. They are responsible for detecting mouse presses to initiate the creation of a connection.

*   **`Connection` and `DataConnection` (`QGraphicsPathItem`):** These classes draw the lines between ports and sockets. `Connection` draws a smooth cubic curve for execution flow, while `DataConnection` draws a dashed, segmented line for data flow. They are responsible for updating their path when the nodes they are connected to are moved.

[NOTE: Insert a diagram showing the hierarchy of the graphical components: SequenceEditor contains SequenceScene, which contains SequenceNodes and Connections.]

## **4.3. Advanced Flow Control: Loops, Conditions, and Parallel Execution**

NodeFlow's sequencer goes beyond simple linear execution, offering powerful constructs for advanced logic.

### **Conditional Branching**

The `Connection` objects can have a condition associated with them. When a node finishes execution, it produces a result. The `SequenceEngine` then evaluates the condition of each outgoing connection against this result.

*   **How it works:** The `ConditionDialog` allows users to set conditions like `==`, `!=`, `>`, `<`, `is True`, `is False`, or even a custom Python expression. When the engine's `evaluate_condition` method runs, it compares the node's output to the configured value or executes the Python expression, returning `True` or `False`.
*   **Example:** A `Method Call` node returns the integer `5`. It has two outgoing connections: one with the condition `== 5` and another with `!= 5`. The engine will follow the first connection and ignore the second.

### **Loops (`For Loop`, `While Loop`)**

Looping is implemented within the `SequenceEngine`. The loop nodes in the editor have special output ports (e.g., "Loop Body" and "Finished").

*   **`For Loop`:** The engine's `execute_for_loop_node` method gets the number of iterations from the node's configuration. It then enters a Python `for` loop. In each iteration, it finds the node connected to the "Loop Body" port and recursively calls the `_execute_graph` method to run that entire branch. Once the loop is finished, it proceeds from the "Finished" port.
*   **`While Loop`:** The `execute_while_loop_node` is more complex. It continuously re-evaluates its data input condition. As long as the condition is met, it executes the "Loop Body" branch. When the condition is no longer met, it exits and continues from the "Finished" port.

### **Parallel Execution (`Fork`, `Join`)**

This feature allows for running multiple branches of a sequence concurrently, which can dramatically speed up processes that involve long, independent delays or tasks.

*   **`Fork` Node:** When the `SequenceEngine` executes a `Fork` node, it finds all outgoing execution connections. It then creates a separate `asyncio.Task` for each branch.
*   **`asyncio.gather`:** The engine then uses `await asyncio.gather(*tasks)` to run all these tasks concurrently. The `gather` call will only complete when *all* the forked branches have finished their execution.
*   **`Join` Node:** The `Join` node is used to synchronize the parallel branches. Each branch must eventually lead to the same `Join` node. The `execute_join_node` method in the engine acts as a counter. The first branch to arrive at the `Join` node records its arrival and then terminates its execution path. Subsequent branches do the same. Only the *last* branch to arrive will satisfy the condition (`arrivals == expected`), allowing the main sequence to continue from the `Join` node's output.

## **4.4. Interactive Debugging and Execution Control**

NodeFlow provides simple yet powerful debugging capabilities, allowing users to pause and inspect a running sequence.

*   **Breakpoints:** Any `SequenceNode` can be toggled as a breakpoint via its context menu. This sets a `has_breakpoint` flag in its configuration.
*   **Pausing Logic:** Inside the `SequenceEngine`'s main loop, before executing any node, it checks for this flag. If `has_breakpoint` is `True`, the engine uses an `asyncio.Event` to pause execution. It emits the `execution_paused` signal, which causes the UI to update (e.g., enabling the "Continue" and "Step" buttons).
*   **Resuming and Stepping:** The "Continue" button simply sets the `asyncio.Event`, allowing the engine's loop to continue running freely. The "Step" buttons also set the event but include logic to pause again at the next opportunity, allowing for step-by-step inspection.

## **4.5. Undo/Redo Framework: The Command Design Pattern**

To provide a robust undo/redo system, the `SequenceScene` uses Qt's `QUndoStack`. This approach is a classic implementation of the **Command Design Pattern**.

Instead of directly modifying the scene (e.g., adding or deleting a node), the scene creates a **Command Object** that encapsulates the action. This object is then "pushed" onto the `QUndoStack`.

### **Custom Command Classes**

NodeFlow defines several classes that inherit from `QUndoCommand`:

*   **`AddNodeCommand`:** Stores the node's configuration and position.
*   **`DeleteItemsCommand`:** Stores the data of the items to be deleted.
*   **`MoveNodesCommand`:** Stores the nodes and their old and new positions.

Each of these classes must implement two key methods:

*   **`redo()`:** This method applies the command. For `AddNodeCommand`, it creates the `SequenceNode` and adds it to the scene. For `DeleteItemsCommand`, it removes the items. The `QUndoStack` calls this method the first time a command is pushed.
*   **`undo()`:** This method reverses the command. For `AddNodeCommand`, it removes the node from the scene. For `DeleteItemsCommand`, it re-creates the items from the stored data and adds them back.

When the user triggers an undo action (e.g., presses Ctrl+Z), the `QUndoStack` simply calls the `undo()` method of the command at the top of the stack. For a redo action, it calls `redo()`. This design pattern provides a clean, reversible history of all significant actions performed by the user in the editor.

---

# **5. User Interface (UI) Component Reference**

This chapter provides a reference for the key components that make up the NodeFlow user interface. It covers the main window, which acts as the application's central hub, the dashboard widget system, and other important UI elements.

## **5.1. Main Window & Orchestrator (`main_window.py`)**

The `MainWindow` class in `app/ui/main_window.py` is the most important UI class in the application. It inherits from `QMainWindow` and acts as the central orchestrator, bringing together all the different panels, docks, and editors into a single, cohesive application.

### **Key Responsibilities and Features:**

*   **Main Layout and Structure:** `MainWindow` is responsible for creating and arranging the primary UI elements:
    *   **Custom Title Bar:** A custom-drawn title bar that includes the window title, connection status, and custom window controls.
    *   **Menu Bar:** The standard application menu (File, Edit, View, etc.).
    *   **Dock Widgets:** The "Server Browser", "Sequence Library", and "Log" panels are implemented as `QDockWidget`s, allowing the user to move, resize, and hide them.
    *   **Main Tab Widget:** A central `QTabWidget` that separates the "Dashboard" and "Sequencer" workspaces.

*   **Project Lifecycle Management:** `MainWindow` handles the entire lifecycle of a NodeFlow project.
    *   **`new_project()`:** Resets the application to a clean state.
    *   **`open_project()`:** Displays a file dialog, then parses the selected `.json` file to reconstruct the entire application state. This includes loading the server URL, rebuilding the dashboard with all its widgets, and loading all sequences.
    *   **`save_project()` / `save_project_as()`:** This is the serialization hub. It gathers the state from all components—it calls the `serialize()` method on every dashboard widget and every open `SequenceEditor`—and aggregates the data into a single dictionary that is then written to a `.json` file.
    *   **Dirty State Tracking:** It maintains an `is_project_dirty` flag. Any significant user action (moving a widget, editing a sequence) sets this flag. If the user tries to close the application or open a new project while the flag is set, `MainWindow` presents a "Save changes?" dialog.

*   **Connection Management:** It owns the instance of `OpcuaClientLogic` and manages the connection lifecycle. It provides the UI (menu items, dialogs) for initiating connections and handles the `connection_lost_callback` to trigger the automatic reconnection timer.

*   **UI Orchestration:** It connects signals from one part of the application to slots in another, acting as the central switchboard. For example:
    *   When a user drags a node from the `ServerTreeView` and drops it onto the `SequenceEditor`, `ServerTreeView` emits a signal. `MainWindow` has a slot connected to this signal, which then calls the `add_node` method on the active `SequenceEditor`.
    *   When a `SequenceWidget` on the dashboard is clicked, it emits a `run_sequence_requested` signal. `MainWindow` listens for this and calls its own `run_sequence_by_name` method, which in turn starts the `SequenceEngine`.

## **5.2. Dashboard and Widgets (`widgets/`)**

The dashboard is a free-form canvas where users can build custom human-machine interfaces (HMIs) for monitoring and interacting with their systems. This is made possible by a modular widget system built on the `BaseWidget` class.

### **The `BaseWidget` Class (`app/ui/widgets/base_widget.py`)**

This class provides the core functionality shared by all dashboard widgets. Subclasses inherit from `BaseWidget` and only need to implement their specific UI and logic, dramatically reducing boilerplate code.

**Common Features Provided by `BaseWidget`:**

*   **Appearance:** A standard frame with a title and a status label.
*   **Interaction:**
    *   **Drag and Drop:** Can be freely moved around the parent `DashboardGrid`.
    *   **Resizing:** A handle in the bottom-right corner allows resizing.
    *   **Selection:** Supports single-click and Ctrl+click selection with a visual border.
*   **Context Menu:** A right-click menu provides common actions:
    *   Minimize/Maximize
    *   Bring to Front / Send to Back
    *   Copy / Duplicate / Delete
*   **Serialization:** A `serialize()` method that captures the widget's configuration, position, and size, allowing the dashboard layout to be saved and loaded.
*   **Minimization:** Can be collapsed to a smaller, summary view to save space.

### **Concrete Widget Implementations**

Here are the standard widgets included with NodeFlow:

*   **`DisplayWidget`:** The most common widget. It subscribes to an OPC UA node and displays its value in real-time. It can be configured for numerical or text display.
*   **`InputWidget`:** Provides a text box for the user to enter a value. When the user presses Enter, the widget performs an OPC UA `write` operation to send the value to a configured node. It can be set for string or numerical input.
*   **`ButtonWidget`:** A simple clickable button. It is configured to perform a specific action when clicked, typically either writing a pre-set value to a node or calling an OPC UA method.
*   **`SwitchWidget`:** A toggle switch that provides a visual representation of a boolean state. Clicking the switch writes `True` or `False` to a configured OPC UA node. It also subscribes to the node's value, so it will update automatically if the state is changed by another source.
*   **`PlotterWidget`:** A widget that uses `matplotlib` to create a real-time plot of a numerical OPC UA node's value over time.
*   **`SequenceWidget`:** A special button that is linked to a specific sequence in the project. Clicking it will start the execution of that sequence via the `SequenceEngine`.

## **5.3. Other UI Components**

Beyond the main window and dashboard widgets, several other UI components are critical to the application's functionality.

*   **`ServerTreeView` (`app/ui/server_tree.py`):**
    This `QTreeView` provides the interactive view of the OPC UA server's address space. After a successful connection, it asynchronously browses the server's nodes and populates the tree. Users can drag nodes from this tree directly onto the dashboard (to create a widget) or into the sequencer (to create a `Method Call` or `Write Value` node).

*   **`SequenceTreeView` (`app/ui/sequence_tree.py`):**
    This is a simpler tree view located in the "Sequence Library" dock. It displays a list of all sequences available in the current project, allowing users to quickly see what workflows have been created.

*   **Configuration Dialogs:**
    A collection of dialog boxes are used to configure various parts of the application. These dialogs provide a user-friendly way to edit the properties that are ultimately stored in the configuration dictionaries of widgets and nodes. Key examples include:
    *   `AddWidgetDialog`: A multi-step dialog for creating a new dashboard widget.
    *   `NodeConfigDialog`: For configuring `Method Call` and `Write Value` nodes in the sequencer.
    *   `ConditionDialog`: For setting the branching conditions on execution connections.
    *   `SettingsDialog`: For application-wide settings like theme selection.

---

# **6. Application Entry and User Guide**

This chapter covers the application's startup process and how it manages persistent user data.

## **6.1. Application Entry Point (`main.py`)**

The `main.py` script is the gateway to the NodeFlow application. When the user runs `python main.py`, this script is responsible for performing the initial setup and launching the main window.

The startup sequence is as follows:

1.  **Configure Logging:** `logging.basicConfig()` is called to set up a basic logging configuration. This ensures that log messages from all parts of the application are captured and displayed in a consistent format in the console.
2.  **Initialize `QApplication`:** An instance of `QApplication` is created. This object manages the GUI application's control flow and main settings. The organization name and application name are set, which is important for `QSettings` to know where to store its data.
3.  **Load and Apply Theme:** The script reads the `theme` value from `QSettings`. It then loads the corresponding `.qss` stylesheet from the `app/resources/styles/` directory and applies it to the entire application. This allows the user's theme preference to be applied immediately on startup.
4.  **Set up Asyncio Event Loop:** This is a critical step.
    *   `loop = QEventLoop(app)`: A `qasync.QEventLoop` is created.
    *   `asyncio.set_event_loop(loop)`: This `QEventLoop` is set as the current event loop for the `asyncio` library.
    This effectively merges the Qt and `asyncio` event loops, allowing them to run together in the same thread.
5.  **Instantiate and Show `MainWindow`:** The main UI of the application, `MainWindow`, is created and displayed.
6.  **Run the Application:** The `with loop:` context manager starts the event loop, and `loop.run_forever()` begins processing events (both UI events like clicks and `asyncio` events like network data). The application will now be running and responsive, and will only exit when the user closes the main window.

## **6.2. Persistent Settings Management (`settings_dialog.py` and `QSettings`)**

To provide a good user experience, an application should remember user preferences and settings between sessions. NodeFlow uses Qt's `QSettings` class for this purpose.

`QSettings` provides a convenient, platform-independent way to store simple application settings. On Windows, it uses the registry; on macOS, it uses `.plist` files; and on Linux, it uses `.ini` files. This is handled automatically, so the developer doesn't need to worry about the underlying platform.

### **Data Stored by NodeFlow:**

NodeFlow stores several key pieces of information to personalize the user's experience and save time:

*   **`theme`:** The name of the last used theme ("Light" or "Dark").
*   **`server_url`:** The URL of the last successfully connected OPC UA server.
*   **`auth_enabled`, `username`, `password`:** The authentication credentials for the last used server. This is stored for convenience, but users should be aware of the security implications of storing passwords in this way.
*   **`recent_projects`:** A list of file paths to the last 10 successfully opened project files. This list is used to populate the "Open Recent" menu and the start page.
*   **`switch_on_run`:** A boolean flag that determines whether the UI should automatically switch to the Sequencer tab when a sequence is started.

### **Usage in the Code:**

Throughout the application, `QSettings` is used to read and write these values.

*   **Writing a setting:**
    ```python
    settings = QSettings()
    settings.setValue("theme", "Dark")
    ```
*   **Reading a setting:**
    ```python
    settings = QSettings()
    # The second argument is a default value if the setting doesn't exist
    theme_name = settings.value("theme", "Dark")
    ```

The `SettingsDialog` class provides a simple UI for the user to change some of these settings, but most are updated automatically as the user interacts with the application (e.g., opening a project automatically adds it to the recent list).

---

# **7. User Guide**

This chapter provides a practical, step-by-step guide to using the main features of NodeFlow. It is written as a tutorial to help a new user get started with the application.

## **7.1. Establishing a Connection and Browsing**

The first step in using NodeFlow is to connect to an OPC UA server.

1.  **Launch NodeFlow.** You will be greeted with the Start Page.
2.  **Create a New Project:** Click the "New Project" button. This will open the main editor view.
3.  **Configure Server Settings:**
    *   Go to the menu `Connections > Server Settings...`.
    *   In the dialog that appears, enter the **Server URL** for your OPC UA server. For a test server running on the same machine, this might be `opc.tcp://localhost:4840/freeopcua/server/`.
    *   If your server requires authentication, check the "Enable Authentication" box and enter your username and password.
    *   Click "OK" to save the settings.
4.  **Connect to the Server:**
    *   Go to the menu `Connections > Connect`.
    *   The status indicator in the top-right of the title bar should turn green, and the text should change to "Server Connected". The Log panel at the bottom will also show connection status messages.
    [NOTE: Add Screenshot of the main window with the connection status highlighted.]
5.  **Browse the Address Space:**
    *   The "Server Browser" dock on the left side of the window will now populate.
    *   Click the arrows to expand the nodes (e.g., `Objects`). You can now browse the entire hierarchy of the server's address space, seeing all the objects and variables it exposes.

## **7.2. Building and Interacting with a Dashboard**

The dashboard lets you create a custom view of your server's data. Let's create a simple widget to display a value.

1.  **Find a Node:** In the "Server Browser", navigate to a variable you want to monitor (e.g., a temperature or counter value).
2.  **Create a Widget:**
    *   Right-click on the desired node in the Server Browser.
    *   From the context menu, select "Create Widget".
3.  **Configure the Widget:**
    *   The "Add Widget" dialog will appear. The Node ID and Search Type will be pre-filled.
    *   For **Widget Type**, select "Numerical Display".
    *   Give the widget a descriptive **Label**, such as "Furnace Temperature".
    *   Click "OK".
4.  **Place the Widget:** A new widget will appear on the dashboard grid.
    *   Click and drag the widget to move it to a desired location.
    *   Move your mouse to the bottom-right corner of the widget until the cursor changes, then click and drag to resize it.
    *   The widget will automatically subscribe to the node and begin displaying its value in real-time.
    [NOTE: Add Screenshot of the dashboard with a few widgets on it.]

## **7.3. Creating and Executing a Basic Automation Sequence**

This tutorial will guide you through creating a simple sequence: read a value, add 10 to it, and write the result back to another node.

1.  **Navigate to the Sequencer:** Click on the "Sequencer" tab in the main window. By default, a "Default Sequence" is already created and open.
2.  **Add a Static Value Node:**
    *   Right-click on an empty area of the grid to open the context menu.
    *   Go to `Add Node > Static Value`. A new node will appear.
    *   Double-click the node. In the dialog, enter `10` as the value and click "OK".
3.  **Add a Method Call Node (to read the value):**
    *   In the Server Browser, find a node that you can read (e.g., "MyVariable").
    *   Right-click on it and select "Add to Sequencer". A new "Method Call" node will appear in the editor. *Correction: This should be a read node, but we'll use a Get Variable node for this example.* Let's assume we have a variable we can read. For this example, we will use a "Get Variable" node.
    *   Right-click the grid > `Add Node > Get Variable`. Double-click it and name it `MyInput`.
4.  **Add a Compute Node:**
    *   Right-click the grid > `Add Node > Compute`.
    *   Double-click it. In the expression field, enter `A + B`. Click "OK".
5.  **Add a Write Value Node:**
    *   Right-click the grid > `Add Node > Write Value`.
    *   Double-click it. In the "Target Node ID" field, enter the Node ID of a variable you can write to (e.g., `ns=2;i=125`).
6.  **Connect the Nodes:**
    *   **Execution Flow (Solid Lines):**
        *   Click and drag from the output port (right side) of the "Get Variable" node to the input port (left side) of the "Compute" node.
        *   Connect the "Compute" node's output port to the "Write Value" node's input port.
    *   **Data Flow (Dashed Lines):**
        *   Click and drag from the data output socket (bottom) of the "Get Variable" node to the 'A' data input socket (top) of the "Compute" node.
        *   Connect the data output of the "Static Value" node to the 'B' data input of the "Compute" node.
        *   Connect the data output of the "Compute" node to the data input of the "Write Value" node.
    [NOTE: Add Screenshot of the completed basic sequence.]
7.  **Run the Sequence:**
    *   Click the "Run" (play) button on the sequencer toolbar at the bottom of the tab.
    *   You will see the nodes and connections highlight in yellow as the sequence executes. Check your OPC UA server to confirm that the value was written correctly.

## **7.4. Using Loops and Debugging a Sequence**

Let's modify the previous sequence to run multiple times and debug it.

1.  **Add a For Loop:**
    *   Delete the first execution connection (from "Get Variable" to "Compute").
    *   Add a `For Loop` node (`Add Node > For Loop`).
    *   Double-click the loop node and set the number of "Iterations" to `3`.
    *   Connect the "Get Variable" node's output port to the "For Loop" node's input port.
    *   The `For Loop` node has two special output ports. Connect the "Loop Body" port to the "Compute" node's input port.
2.  **Set a Breakpoint:**
    *   Right-click on the "Write Value" node.
    *   From the context menu, select "Toggle Breakpoint". A red circle will appear on the node.
3.  **Run and Debug:**
    *   Click the "Run" button.
    *   The sequence will run and then pause just before executing the "Write Value" node. The node will be highlighted in blue.
    *   The debugging buttons on the toolbar ("Continue", "Step Over") are now enabled.
    *   Click "Continue" to let the sequence run to completion for the current loop iteration. It will pause again at the breakpoint on the next iteration.
    *   Click "Stop" to terminate the execution at any time.

## **7.5. Finding Nodes Across the Project**

In a large project with many sequences, it can be hard to find a specific node.

1.  **Open the Find Dialog:** Go to the menu `Edit > Find in Project...`.
2.  **Search:** Enter a term that is part of the node's label (e.g., "Compute").
3.  **View Results:** The dialog will show a list of all nodes in all sequences that match the term.
4.  **Navigate:** Double-click on a result. NodeFlow will automatically open the correct sequence tab and highlight the corresponding node.

---

# **8. Conclusion & Glossary**

## **8.1. Conclusion**

NodeFlow was born from the need for a more flexible, intuitive, and powerful tool in the modern industrial automation landscape. By combining a graphical, node-based workflow editor with a native, high-performance OPC UA communication stack, it successfully bridges the gap between complex industrial hardware and user-friendly software design.

Throughout this document, we have explored the key architectural pillars of NodeFlow:

*   **A Decoupled Architecture:** The strict separation of the OPC UA communication logic (`OpcuaClientLogic`) and the sequence execution backend (`SequenceEngine`) from the user interface (`MainWindow`, `SequenceEditor`) makes the application robust, testable, and maintainable.
*   **A Responsive, Asynchronous Core:** The seamless integration of `asyncio` with the `PyQt6` event loop via `qasync` is the cornerstone of the application's performance, ensuring that slow network operations never compromise the user experience.
*   **A Powerful and Extensible Sequencer:** The graphical sequencer, with its support for advanced flow control, parallel execution, and interactive debugging, provides a rich environment for creating complex automation logic without writing code.
*   **A Customizable HMI Dashboard:** The modular widget system allows users to quickly build custom interfaces for monitoring and interacting with their systems in real-time.

NodeFlow stands as a powerful tool for a wide range of applications, from test automation and data logging to process control and research. Its foundation on the open standard of OPC UA ensures its relevance and interoperability for years to come.

### **Future Directions**

The modular architecture of NodeFlow provides a solid foundation for future expansion. Potential future enhancements could include:

*   **An Expanded Node Library:** Adding new, specialized nodes to the sequencer for tasks like database interaction (SQL), MQTT communication, or calling REST APIs.
*   **Advanced Dashboard Widgets:** Introducing more sophisticated widgets like gauges, charts, or even 3D model viewers.
*   **A Plugin System:** Developing a formal plugin architecture that would allow third-party developers to create and share their own custom nodes and widgets.
*   **Cloud Integration:** Enhancing capabilities for interacting directly with cloud platforms like AWS IoT or Azure IoT Hub.

Ultimately, NodeFlow is more than just a software application; it is a platform for innovation, designed to empower engineers, technicians, and scientists to build the automated systems of the future.

## **8.2. Glossary of Terms**

*   **Address Space:** In OPC UA, this is the structured, hierarchical model of objects, variables, and methods that a server exposes to clients. It's the server's representation of its own data and capabilities.
*   **Dashboard:** In NodeFlow, the user-configurable workspace where widgets are placed to create a custom HMI.
*   **Node (in NodeFlow Sequencer):** A graphical block in the sequence editor that represents a single action or operation (e.g., `Method Call`, `Delay`, `Write Value`).
*   **Node (in OPC UA):** A fundamental component of the OPC UA Address Space. A node can be an Object, a Variable, a Method, or one of several other types. Each node is uniquely identified by a `NodeId`.
*   **OPC UA (Open Platform Communications Unified Architecture):** A modern, platform-independent, secure, and scalable communication framework for industrial automation. It is the primary communication protocol used by NodeFlow.
*   **QSettings:** A PyQt class used for storing persistent application settings in a platform-independent way (e.g., in the Windows Registry or `.ini` files on Linux).
*   **QSS (Qt Style Sheets):** A mechanism, similar to CSS for web pages, that allows the look and feel of a PyQt application to be customized. NodeFlow uses `.qss` files for its theme support.
*   **Sequence:** A workflow created in NodeFlow's graphical sequencer, consisting of interconnected nodes that define a series of actions to be executed.
*   **Signal and Slot:** The core communication mechanism in PyQt. A signal is emitted when an event occurs, and a slot is a function that is called in response to a signal. This enables a loosely coupled, event-driven architecture.
*   **Subscription:** A high-efficiency mechanism in OPC UA where a client asks a server to monitor a set of nodes and notify it only when their values change. This is far more efficient than repeatedly polling for values.
*   **Widget:** In NodeFlow, a component on the dashboard used to visualize or interact with OPC UA data (e.g., `DisplayWidget`, `ButtonWidget`).
